
// Version that just forks and execs the commands 'avahi-browse' or 'avahi-publish'
// Using the Avahi API is a nightmare; it's a twisted mess of callbacks between "callbacks", "services", "resolvers", etc.
// March 2024, Phil Karn KA9Q
// Jan 2025 - option to publish through static additions to avahi daemon files /etc/avahi/hosts, /etc/avahi/services
//            note - does not remove such entries yet!
#define _GNU_SOURCE 1
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <string.h>
#include <errno.h>
#include <sys/file.h>
#include <stdbool.h>
#include <ctype.h>
#include "misc.h"
#include "avahi.h"

#define SERVICES "/etc/avahi/services"
#define HOSTS "/etc/avahi/hosts"

bool Static_avahi;

int avahi_publish_address(char const *dns_name,char const *ip_address_string);
int avahi_publish_service(char const *service_name, char const *service_type, char const *dns_name,int service_port, char const *description, int pid);
static void sanitize_filename(char *name);

int avahi_start(char const *service_name,char const *service_type,int const service_port,char const *dns_name,int address,char const *description,void *sock,size_t *socksize){
  if(sock != NULL && socksize != NULL){
    // Return sockaddr structure
    if(*socksize >= sizeof(struct sockaddr_in)){
      struct sockaddr_in *sin = sock;
      sin->sin_family = AF_INET;
      sin->sin_addr.s_addr = htonl(address);
      sin->sin_port = htons(service_port);
      *socksize = sizeof(struct sockaddr_in);
    } else
      *socksize = 0;
  }
  int pid = getpid(); // Advertise the parent's pid, not the child's
  if(Static_avahi){
    // Just put in /etc/avahi/services
    avahi_publish_service(service_name, service_type, dns_name,service_port,description,pid);
  } else { // static = no
    if(fork() == 0){
#if 0
      fprintf(stdout,"avahi-publish-service child pid %d\n",getpid());
#endif
      // run "avahi-publish-service --no-fail --host=dns_name service_name service_type service_port description pid hostname" in subprocess
      // No need to free the asprintf-allocated strings, we're calling exec anyway
      // Turn off warnings about unused return values from asprintf generated by some compilers
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-result"
      char *port_string = NULL;
      asprintf(&port_string, "%d", service_port);

      char *host_string = NULL;
      asprintf(&host_string, "--host=%s",dns_name);

      char *pid_string = NULL;
      asprintf(&pid_string, "pid=%d", pid);

      char hostname[sysconf(_SC_HOST_NAME_MAX)];
      gethostname(hostname,sizeof(hostname));
      char *source_string = NULL;
      asprintf(&source_string, "source=%s", hostname);
#pragma GCC diagnostic pop

#if 0
      fprintf(stdout,"%s %s %s %s %s %s %s %s %s %s\n",
	      "avahi-publish-service", "avahi-publish-service", "--no-fail", host_string, service_name, service_type, port_string, description, pid_string, hostname);
#endif
      execlp("avahi-publish-service", "avahi-publish-service", "--no-fail", host_string, service_name, service_type, port_string, description, pid_string, source_string, NULL);
      perror("exec avahi publish service");
      return -1;
    }
  }
  if(address != 0){
    char *ip_address_string = NULL;    // No need to free, we're calling exec
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-result"
    asprintf(&ip_address_string,"%d.%d.%d.%d",(address >> 24) & 0xff, (address >> 16) & 0xff, (address >> 8) & 0xff, address & 0xff);
#pragma GCC diagnostic pop
    if(Static_avahi){
      // Just put in /etc/avahi/hosts
      avahi_publish_address(dns_name,ip_address_string);
    } else {
      if(fork() == 0){
	// run "avahi-publish-address dns_name address", only if an address is specified

#if 0
	fprintf(stdout,"avahi start: ip address string = %s\n",ip_address_string);
	fprintf(stdout,"avahi-publish-address child pid %d\n",getpid());
	fprintf(stdout,"%s %s %s %s\n",
		"avahi-publish-address", "avahi-publish-address",dns_name,ip_address_string);
#endif
	execlp("avahi-publish-address", "avahi-publish-address",dns_name,ip_address_string, NULL);
	perror("exec avahi publish address");
	return -1;
      }
    }
  }
  return 0;
}

// Publish service in static avahi directory
int avahi_publish_service(char const *service_name, char const *service_type, char const *dns_name,int service_port, char const *description, int pid){

  char *sanitized_name = strdup(service_name);
  sanitize_filename(sanitized_name);

  char tmp_file[1024];
  snprintf(tmp_file,sizeof(tmp_file),"%s/%s.service.tmp%d",SERVICES,sanitized_name,pid);
  FILE *fp = fopen(tmp_file,"w"); // Will overwrite if exists
  if(fp == NULL){
    fprintf(stdout,"Can't create %s: %s\n",tmp_file,strerror(errno));
    FREE(sanitized_name);
    return -1;
  }
  char hostname[sysconf(_SC_HOST_NAME_MAX)];
  gethostname(hostname,sizeof(hostname));

  fputs("<service-group>\n",fp);
  fprintf(fp,"<name>%s</name>\n",service_name);
  fputs("<service protocol=\"ipv4\">\n",fp);
  fprintf(fp,"<host-name>%s</host-name>\n",dns_name);
  fprintf(fp,"<type>%s</type>\n",service_type);
  fprintf(fp,"<port>%d</port>\n",service_port);
  fprintf(fp,"<txt-record>pid=%d</txt-record>\n",pid);
  fprintf(fp,"<txt-record>%s</txt-record>\n",description);
  fprintf(fp,"<txt-record>source=%s</txt-record>\n",hostname);
  fputs("</service>\n",fp);
  fputs("</service-group>\n",fp);
  fclose(fp);
  char service_file[1024];
  snprintf(service_file,sizeof(service_file),"%s/%s.service",SERVICES,sanitized_name);

  int r = rename(tmp_file,service_file);
  if(r != 0)
    fprintf(stderr,"Can't rename %s to %s: %s\n",
	    tmp_file,service_file,strerror(errno));
  FREE(sanitized_name);

  return r;
}

// Publish address, host pair in static avahi file

int avahi_publish_address(char const *name,char const *address){
  FILE *fp = fopen(HOSTS,"a+");
  if(fp == NULL){
    fprintf(stdout,"Can't open %s: %s\n",HOSTS,strerror(errno));
    return -1;
  }
  // the lock has to be exclusive even when reading, otherwise there could be double entries
  if(flock(fileno(fp),LOCK_EX) != 0){
    fprintf(stderr,"Can't lock %s: %s\n",HOSTS,strerror(errno));
    fclose(fp);
    return -1;
  }
  rewind(fp); // Start reading at front
  char *buffer = NULL;
  size_t linecap = 0;
  int linelen;
  while((linelen = getline(&buffer,&linecap,fp)) > 0){
    char *cp;
    if((cp = strchr(buffer,'\n')) != NULL)
      *cp = '\0';
    if(buffer[0] == '#')
      continue;
    char *line = buffer;
    char const *faddr = strsep(&line," \t");
    if(faddr == NULL || line == NULL)
      continue;

    // Skip multiple white space
    while(*line == ' ' || *line == '\t')
      line++;

    char const *fname = line;
    if(fname == NULL || *fname == '\0')
      continue;

    // These are string comparisons so there might be a false mismatch
    // if they're written differently. redo as compares of canonical forms
    // Also, what are the rules about the same names with different addresses
    // and vice versa?
    if(strcmp(name,fname) == 0 && strcmp(address,faddr) == 0){
      // Yes, entry is already present, don't do anything
      flock(fileno(fp),LOCK_UN);
      fclose(fp);
      free(buffer);
      return 0;
    }
  }
  free(buffer);
  // we've read the entire file without a match, so append our record
  // The "a+" open mode means we'll append
  if(fprintf(fp,"%s %s\n",address,name) < 0)
    fprintf(stdout,"Can't append to %s: %s\n",HOSTS,strerror(errno));
  flock(fileno(fp),LOCK_UN); // Upgrade to exclusive lock for writing
  fclose(fp);

  return 0;
}
// Remove problematic characters from an Avahi service file name
static void sanitize_filename(char *name) {
  char *src = name;
  char *dst = name;

  // Trim leading whitespace
  while (isspace((unsigned char)*src))
    src++;

  while (*src) {
    unsigned char c = (unsigned char)*src;
    if (isalnum(c)) {
      *dst++ = c;
    } else if (c == ' ' || c == '_' || c == '-' || c == '@') {
      *dst++ = '-';  // Normalize all to hyphen
    } else if (c == '.') {
      *dst++ = '.';  // Keep dot for extension
    } else {
      // Drop anything else (e.g., control chars, punctuation)
    }
    src++;
  }
  // Trim trailing hyphens or whitespace
  while (dst > name && (dst[-1] == '-' || isspace((unsigned char)dst[-1])))
    dst--;
  *dst = '\0';
}
